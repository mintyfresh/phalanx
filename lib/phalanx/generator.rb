# typed: strict
# frozen_string_literal: true

module Phalanx
  class Generator
    extend T::Sig

    sig { params(permission_groups: T::Array[Parser::PermissionGroup], output_class_name: String, output_path: Pathname).void }
    def initialize(permission_groups, output_class_name:, output_path:)
      @permission_groups = permission_groups
      @output_class_name = output_class_name
      @output_path = output_path
    end

    sig { returns(T::Boolean) }
    def stale?
      file = Tempfile.new(['permission', '.rb'])
      write_file(file)
      file.flush

      !FileUtils.identical?(@output_path, T.must(file.path))
    ensure
      file&.close
    end

    sig { void }
    def generate
      file = File.open(@output_path, 'w')
      write_file(file)
    ensure
      file&.close
    end

  private

    sig { params(file: T.any(File, Tempfile)).void }
    def write_file(file)
      write_file_header(file)
      write_class_definition(file)
      write_enum_values(file)
      write_class_footer(file)
    end

    sig { params(file: T.any(File, Tempfile)).void }
    def write_file_header(file)
      file.write <<~HEADER
        # typed: strict
        # frozen_string_literal: true

        # GENERATED FILE - DO NOT MODIFY
        # This file was generated by Phalanx.
        # Use `rails phalanx:generate` to regenerate this file.

      HEADER
    end

    sig { params(file: T.any(File, Tempfile)).void }
    def write_class_definition(file)
      file.write <<~CLASS_DEFINITION
        class #{@output_class_name} < T::Enum
          extend T::Sig

          include Phalanx::Permission

      CLASS_DEFINITION
    end

    sig { params(file: T.any(File, Tempfile)).void }
    def write_enum_values(file)
      file.write("  enums do\n")
      @permission_groups.each_with_index do |permission_group, index|
        file.write("    # Permissions for #{permission_group.name}\n\n")

        permission_group.permissions.each do |permission|
          write_permission(file, permission_group, permission)
        end

        file.write("\n") if index < @permission_groups.size - 1
      end
      file.write("  end\n")
    end

    sig { params(file: T.any(File, Tempfile), permission_group: Parser::PermissionGroup, permission: Parser::Permission).void }
    def write_permission(file, permission_group, permission)
      file.write("    # #{permission.description&.squish}\n") if permission.description.present?
      file.write("    #{permission.constant_name} = new(\n")
      file.write("      id: #{permission.id.inspect},\n")
      file.write("      group_name: #{permission_group.name.inspect},\n")
      file.write("      name: #{permission.name.inspect},\n")
      file.write("      description: #{permission.description.inspect},\n")
      file.write("      depends_on: #{permission.depends_on.inspect},\n")
      file.write("    )\n")
    end

    sig { params(file: T.any(File, Tempfile)).void }
    def write_class_footer(file)
      file.write("end\n")
    end
  end
end
